
  <!DOCTYPE html>
  <html>
    <head>
      <title>stark.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/utils/stark.ts</td><td class="">100.00%</td><td class="">80%</td><td class="">290</td><td class="">290</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { getStarkKey, utils } from &#x27;@scure/starknet&#x27;;
import { gzip, ungzip } from &#x27;pako&#x27;;

import { ZERO, feeMarginPercentage } from &#x27;../constants&#x27;;
import {
  ArraySignatureType,
  BigNumberish,
  CompressedProgram,
  Program,
  Signature,
  UniversalDetails,
} from &#x27;../types&#x27;;
import { EDAMode, EDataAvailabilityMode, ETransactionVersion, ResourceBounds } from &#x27;../types/api&#x27;;
import { FeeEstimate } from &#x27;../types/provider&#x27;;
import { addHexPrefix, arrayBufferToString, atobUniversal, btoaUniversal } from &#x27;./encode&#x27;;
import { parse, stringify } from &#x27;./json&#x27;;
import {
  addPercent,
  bigNumberishArrayToDecimalStringArray,
  bigNumberishArrayToHexadecimalStringArray,
  isBigInt,
  toHex,
} from &#x27;./num&#x27;;
import { isString } from &#x27;./shortString&#x27;;

/**
 * Compress compiled Cairo program
 *
 * [Reference](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/services/api/gateway/transaction.py#L54-L58)
 * @param jsonProgram Representing the compiled cairo program
 */
export function compressProgram(jsonProgram: Program | string): CompressedProgram {
  const stringified = isString(jsonProgram) ? jsonProgram : stringify(jsonProgram);
  const compressedProgram = gzip(stringified);
  return btoaUniversal(compressedProgram);
}

/**
 * Decompress compressed compiled Cairo program
 * @param base64 Compressed program
 * @returns Parsed decompressed compiled Cairo program
 */
export function decompressProgram(base64: CompressedProgram) {
  if (Array.isArray(base64)) return base64;
  const decompressed = arrayBufferToString(ungzip(atobUniversal(base64)));
  return parse(decompressed);
}

/**
 * Random Address based on random keyPair
 */
export function randomAddress(): string {
  const randomKeyPair = utils.randomPrivateKey();
  return getStarkKey(randomKeyPair);
}

/**
 * Lowercase and hex prefix string
 *
 * @deprecated Not used internally, naming is confusing based on functionality
 */
export function makeAddress(input: string): string {
  return addHexPrefix(input).toLowerCase();
}

/**
 * Format Signature to standard type (hex array)
 * @returns Custom hex array or weierstrass.SignatureType hex array
 */
export function formatSignature(sig?: Signature): ArraySignatureType {
  if (!sig) throw Error(&#x27;formatSignature: provided signature is undefined&#x27;);
  if (Array.isArray(sig)) {
    return sig.map((it) =&gt; toHex(it));
  }
  try {
    const { r, s } = sig;
    return [toHex(r), toHex(s)];
  } catch (e) {
    throw new Error(&#x27;Signature need to be weierstrass.SignatureType or an array for custom&#x27;);
  }
}

/**
 * Format Signature to decimal string array
 */
export function signatureToDecimalArray(sig?: Signature): ArraySignatureType {
  return bigNumberishArrayToDecimalStringArray(formatSignature(sig));
}

/**
 * Format Signature to hex string array
 */
export function signatureToHexArray(sig?: Signature): ArraySignatureType {
  return bigNumberishArrayToHexadecimalStringArray(formatSignature(sig));
}

/**
 * Convert estimated fee to max fee with overhead
 */
export function estimatedFeeToMaxFee(
  estimatedFee: BigNumberish,
  overhead: number = feeMarginPercentage.MAX_FEE
): bigint {
  return addPercent(estimatedFee, overhead);
}

/**
 * Calculates the maximum resource bounds for fee estimation.
 *
 * @param {FeeEstimate|0n} estimate - The estimate for the fee. If a BigInt is provided,
 *                                    the returned bounds will be set to &#x27;0x0&#x27;.
 * @param {number} [amountOverhead=feeMarginPercentage.L1_BOUND_MAX_AMOUNT] - The percentage
 *                                                                             overhead added to
 *                                                                             the gas consumed or
 *                                                                             overall fee amount.
 * @param {number} [priceOverhead=feeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT] - The percentage
 *                                                                                  overhead added to
 *                                                                                  the gas price per unit.
 * @throws {Error} If the estimate object is undefined or does not have the required properties.
 * @returns {ResourceBounds} The maximum resource bounds for fee estimation.
 */
export function estimateFeeToBounds(
  estimate: FeeEstimate | 0n,
  amountOverhead: number = feeMarginPercentage.L1_BOUND_MAX_AMOUNT,
  priceOverhead: number = feeMarginPercentage.L1_BOUND_MAX_PRICE_PER_UNIT
): ResourceBounds {
  if (isBigInt(estimate)) {
    return {
      l2_gas: { max_amount: &#x27;0x0&#x27;, max_price_per_unit: &#x27;0x0&#x27; },
      l1_gas: { max_amount: &#x27;0x0&#x27;, max_price_per_unit: &#x27;0x0&#x27; },
    };
  }

  if (typeof estimate.gas_consumed === &#x27;undefined&#x27; || typeof estimate.gas_price === &#x27;undefined&#x27;) {
    throw Error(&#x27;estimateFeeToBounds: estimate is undefined&#x27;);
  }

  const maxUnits =
    estimate.data_gas_consumed !== undefined &amp;&amp; estimate.data_gas_price !== undefined // RPC v0.7
      ? toHex(addPercent(BigInt(estimate.overall_fee) / BigInt(estimate.gas_price), amountOverhead))
      : toHex(addPercent(estimate.gas_consumed, amountOverhead));
  const maxUnitPrice = toHex(addPercent(estimate.gas_price, priceOverhead));
  return {
    l2_gas: { max_amount: &#x27;0x0&#x27;, max_price_per_unit: &#x27;0x0&#x27; },
    l1_gas: { max_amount: maxUnits, max_price_per_unit: maxUnitPrice },
  };
}

/**
 * Converts the data availability mode from EDataAvailabilityMode to EDAMode.
 *
 * @param {EDataAvailabilityMode} dam - The data availability mode to be converted.
 * @return {EDAMode} The converted data availability mode.
 * @throws {Error} If the data availability mode is not a valid value.
 */
export function intDAM(dam: EDataAvailabilityMode) {
  if (dam === EDataAvailabilityMode.L1) return EDAMode.L1;
  if (dam === EDataAvailabilityMode.L2) return EDAMode.L2;
  throw Error(&#x27;EDAM conversion&#x27;);
}

/**
 * Convert to ETransactionVersion or throw an error.
 * Return providedVersion is specified else return defaultVersion
 * @param defaultVersion BigNumberish
 * @param providedVersion BigNumberish | undefined
 * @returns ETransactionVersion
 */
export function toTransactionVersion(defaultVersion: BigNumberish, providedVersion?: BigNumberish) {
  const providedVersion0xs = providedVersion ? toHex(providedVersion) : undefined;
  const defaultVersion0xs = toHex(defaultVersion);

  if (providedVersion &amp;&amp; !Object.values(ETransactionVersion).includes(providedVersion0xs as any)) {
    throw Error(`providedVersion ${providedVersion} is not ETransactionVersion`);
  }
  if (!Object.values(ETransactionVersion).includes(defaultVersion0xs as any)) {
    throw Error(`defaultVersion ${defaultVersion} is not ETransactionVersion`);
  }

  return (providedVersion ? providedVersion0xs : defaultVersion0xs) as ETransactionVersion;
}

/**
 * Convert Transaction version to Fee version or throw an error
 * @param providedVersion BigNumberish | undefined
 */
export function toFeeVersion(providedVersion?: BigNumberish) {
  if (!providedVersion) return undefined;
  const version = toHex(providedVersion);

  if (version === ETransactionVersion.V0) return ETransactionVersion.F0;
  if (version === ETransactionVersion.V1) return ETransactionVersion.F1;
  if (version === ETransactionVersion.V2) return ETransactionVersion.F2;
  if (version === ETransactionVersion.V3) return ETransactionVersion.F3;

  throw Error(`toFeeVersion: ${version} is not supported`);
}

/**
 * Return provided or default v3 tx details
 */
export function v3Details(details: UniversalDetails) {
  return {
    tip: details.tip || 0,
    paymasterData: details.paymasterData || [],
    accountDeploymentData: details.accountDeploymentData || [],
    nonceDataAvailabilityMode: details.nonceDataAvailabilityMode || EDataAvailabilityMode.L1,
    feeDataAvailabilityMode: details.feeDataAvailabilityMode || EDataAvailabilityMode.L1,
    resourceBounds: details.resourceBounds ?? estimateFeeToBounds(ZERO),
  };
}

/**
 * It will reduce V2 to V1, else (V3) stay the same
 * F2 -&gt; F1
 * V2 -&gt; V1
 * F3 -&gt; F3
 * V3 -&gt; V3
 */
export function reduceV2(providedVersion: ETransactionVersion) {
  if (providedVersion === ETransactionVersion.F2) return ETransactionVersion.F1;
  if (providedVersion === ETransactionVersion.V2) return ETransactionVersion.V1;
  return providedVersion;
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Apr 2024 15:57:37 GMT</p>
    </body>
  </html>
  