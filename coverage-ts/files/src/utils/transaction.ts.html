
  <!DOCTYPE html>
  <html>
    <head>
      <title>transaction.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/utils/transaction.ts</td><td class="">100.00%</td><td class="">80%</td><td class="">228</td><td class="">228</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { UDC } from &#x27;../constants&#x27;;
import {
  BigNumberish,
  CairoVersion,
  Call,
  CallStruct,
  Calldata,
  ParsedStruct,
  RawArgs,
  UniversalDeployerContractPayload,
} from &#x27;../types&#x27;;
import { ETransactionVersion } from &#x27;../types/api&#x27;;
import { CallData } from &#x27;./calldata&#x27;;
import { starkCurve } from &#x27;./ec&#x27;;
import { calculateContractAddressFromHash, getSelectorFromName } from &#x27;./hash&#x27;;
import { toBigInt, toCairoBool } from &#x27;./num&#x27;;
import { randomAddress } from &#x27;./stark&#x27;;

/**
 * Transforms a list of Calls, each with their own calldata, into
 * two arrays: one with the entry points, and one with the concatenated calldata
 */
export const transformCallsToMulticallArrays = (calls: Call[]) =&gt; {
  const callArray: ParsedStruct[] = [];
  const calldata: BigNumberish[] = [];
  calls.forEach((call) =&gt; {
    const data = CallData.compile(call.calldata || []);
    callArray.push({
      to: toBigInt(call.contractAddress).toString(10),
      selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
      data_offset: calldata.length.toString(),
      data_len: data.length.toString(),
    });
    calldata.push(...data);
  });
  return {
    callArray,
    calldata: CallData.compile({ calldata }),
  };
};

/**
 * Transforms a list of calls into the Cairo 0 `__execute__` calldata.
 */
export const fromCallsToExecuteCalldata = (calls: Call[]) =&gt; {
  const { callArray, calldata } = transformCallsToMulticallArrays(calls);
  const compiledCalls = CallData.compile({ callArray });
  return [...compiledCalls, ...calldata] as Calldata;
};

/**
 * Transforms a list of calls into the Cairo 0 `__execute__` calldata including nonce.
 *
 * @deprecated
 */
export const fromCallsToExecuteCalldataWithNonce = (calls: Call[], nonce: BigNumberish) =&gt; {
  return [...fromCallsToExecuteCalldata(calls), toBigInt(nonce).toString()] as Calldata;
};

/**
 * Format Data inside Calls
 *
 * @deprecated Not required for getting execute Calldata
 */
export const transformCallsToMulticallArrays_cairo1 = (calls: Call[]) =&gt; {
  const callArray = calls.map&lt;CallStruct&gt;((call) =&gt; ({
    to: toBigInt(call.contractAddress).toString(10),
    selector: toBigInt(getSelectorFromName(call.entrypoint)).toString(10),
    calldata: CallData.compile(call.calldata || []),
  }));
  return callArray;
};

/**
 * Transforms a list of calls into the Cairo 1 `__execute__` calldata.
 */
export const fromCallsToExecuteCalldata_cairo1 = (calls: Call[]) =&gt; {
  // ensure property order
  const orderCalls = calls.map((call) =&gt; ({
    contractAddress: call.contractAddress,
    entrypoint: call.entrypoint,
    calldata:
      Array.isArray(call.calldata) &amp;&amp; &#x27;__compiled__&#x27; in call.calldata
        ? call.calldata // Calldata type
        : CallData.compile(call.calldata as RawArgs), // RawArgsObject | RawArgsArray type
  }));

  return CallData.compile({ orderCalls });
};

/**
 * Create `__execute__` Calldata from Calls based on Cairo versions
 */
export const getExecuteCalldata = (calls: Call[], cairoVersion: CairoVersion = &#x27;0&#x27;) =&gt; {
  if (cairoVersion === &#x27;1&#x27;) {
    return fromCallsToExecuteCalldata_cairo1(calls);
  }
  return fromCallsToExecuteCalldata(calls);
};

/**
 * Builds a UDCCall object.
 *
 * @param {UniversalDeployerContractPayload | UniversalDeployerContractPayload[]} payload - The payload data for the UDCCall. Can be a single payload object or an array of payload objects
 *.
 * @param {string} address - The address to be used in the UDCCall.
 * @returns {{ calls: Array, addresses: Array }} - The UDCCall object containing an array of calls and an array of addresses.
 */
export function buildUDCCall(
  payload: UniversalDeployerContractPayload | UniversalDeployerContractPayload[],
  address: string
) {
  const params = [].concat(payload as []).map((it) =&gt; {
    const {
      classHash,
      salt,
      unique = true,
      constructorCalldata = [],
    } = it as UniversalDeployerContractPayload;

    const compiledConstructorCallData = CallData.compile(constructorCalldata);
    const deploySalt = salt ?? randomAddress();

    return {
      call: {
        contractAddress: UDC.ADDRESS,
        entrypoint: UDC.ENTRYPOINT,
        calldata: [
          classHash,
          deploySalt,
          toCairoBool(unique),
          compiledConstructorCallData.length,
          ...compiledConstructorCallData,
        ],
      },
      address: calculateContractAddressFromHash(
        unique ? starkCurve.pedersen(address, deploySalt) : deploySalt,
        classHash,
        compiledConstructorCallData,
        unique ? UDC.ADDRESS : 0
      ),
    };
  });

  return {
    calls: params.map((it) =&gt; it.call),
    addresses: params.map((it) =&gt; it.address),
  };
}

/**
 * Return transaction versions based on version type, default version type is &#x27;transaction&#x27;
 */
export function getVersionsByType(versionType?: &#x27;fee&#x27; | &#x27;transaction&#x27;) {
  return versionType === &#x27;fee&#x27;
    ? {
        v1: ETransactionVersion.F1,
        v2: ETransactionVersion.F2,
        v3: ETransactionVersion.F3,
      }
    : { v1: ETransactionVersion.V1, v2: ETransactionVersion.V2, v3: ETransactionVersion.V3 };
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Apr 2024 15:57:37 GMT</p>
    </body>
  </html>
  