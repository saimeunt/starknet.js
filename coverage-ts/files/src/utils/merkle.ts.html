
  <!DOCTYPE html>
  <html>
    <head>
      <title>merkle.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/utils/merkle.ts</td><td class="">100.00%</td><td class="">80%</td><td class="">184</td><td class="">184</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { BigNumberish } from &#x27;../types&#x27;;
import { computePedersenHash } from &#x27;./hash&#x27;;

export class MerkleTree {
  public leaves: string[];

  public branches: string[][] = [];

  public root: string;

  public hashMethod: (a: BigNumberish, b: BigNumberish) =&gt; string;

  constructor(
    leafHashes: string[],
    hashMethod: (a: BigNumberish, b: BigNumberish) =&gt; string = computePedersenHash
  ) {
    this.hashMethod = hashMethod;
    this.leaves = leafHashes;
    this.root = this.build(leafHashes);
  }

  /**
   * Create Merkle tree
   * @param leaves hex-string array
   * @returns format: hex-string; Merkle tree root
   */
  private build(leaves: string[]): string {
    if (leaves.length === 1) {
      return leaves[0];
    }
    if (leaves.length !== this.leaves.length) {
      this.branches.push(leaves);
    }
    const newLeaves: string[] = [];
    for (let i = 0; i &lt; leaves.length; i += 2) {
      if (i + 1 === leaves.length) {
        newLeaves.push(MerkleTree.hash(leaves[i], &#x27;0x0&#x27;, this.hashMethod));
      } else {
        newLeaves.push(MerkleTree.hash(leaves[i], leaves[i + 1], this.hashMethod));
      }
    }
    return this.build(newLeaves);
  }

  /**
   * Create hash from ordered a and b, Pedersen hash default
   * @returns format: hex-string
   */
  static hash(
    a: BigNumberish,
    b: BigNumberish,
    hashMethod: (a: BigNumberish, b: BigNumberish) =&gt; string = computePedersenHash
  ) {
    const [aSorted, bSorted] = [BigInt(a), BigInt(b)].sort((x, y) =&gt; (x &gt;= y ? 1 : -1));
    return hashMethod(aSorted, bSorted);
  }

  /**
   * Return path to leaf
   * @param leaf hex-string
   * @param branch hex-string array
   * @param hashPath hex-string array
   * @returns format: hex-string array
   */
  public getProof(leaf: string, branch = this.leaves, hashPath: string[] = []): string[] {
    const index = branch.indexOf(leaf);
    if (index === -1) {
      throw new Error(&#x27;leaf not found&#x27;);
    }
    if (branch.length === 1) {
      return hashPath;
    }
    const isLeft = index % 2 === 0;
    const neededBranch = (isLeft ? branch[index + 1] : branch[index - 1]) ?? &#x27;0x0&#x27;;
    const newHashPath = [...hashPath, neededBranch];
    const currentBranchLevelIndex =
      this.leaves.length === branch.length
        ? -1
        : this.branches.findIndex((b) =&gt; b.length === branch.length);
    const nextBranch = this.branches[currentBranchLevelIndex + 1] ?? [this.root];
    return this.getProof(
      MerkleTree.hash(isLeft ? leaf : neededBranch, isLeft ? neededBranch : leaf, this.hashMethod),
      nextBranch,
      newHashPath
    );
  }
}

/**
 * Test Merkle tree path
 * @param root hex-string
 * @param leaf hex-string
 * @param path hex-string array
 * @param hashMethod hash method override, Pedersen default
 */
export function proofMerklePath(
  root: string,
  leaf: string,
  path: string[],
  hashMethod: (a: BigNumberish, b: BigNumberish) =&gt; string = computePedersenHash
): boolean {
  if (path.length === 0) {
    return root === leaf;
  }
  const [next, ...rest] = path;
  return proofMerklePath(root, MerkleTree.hash(leaf, next, hashMethod), rest, hashMethod);
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Apr 2024 15:57:37 GMT</p>
    </body>
  </html>
  