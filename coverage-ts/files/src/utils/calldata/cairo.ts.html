
  <!DOCTYPE html>
  <html>
    <head>
      <title>cairo.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/utils/calldata/cairo.ts</td><td class="">87.43%</td><td class="">80%</td><td class="">191</td><td class="">167</td><td class="">24</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import {
  Abi,
  AbiEnums,
  AbiStructs,
  BigNumberish,
  ContractVersion,
  Literal,
  Uint,
  Uint256,
  Uint512,
} from &#x27;../../types&#x27;;
import { CairoFelt } from &#x27;../cairoDataTypes/felt&#x27;;
import { CairoUint256 } from &#x27;../cairoDataTypes/uint256&#x27;;
import { CairoUint512 } from &#x27;../cairoDataTypes/uint512&#x27;;

// Intended for internal usage, maybe should be exported somewhere else and not exported to utils
/**
 * Checks if the given name ends with &quot;_len&quot;.
 *
 * @param {string} name - The name to be checked.
 * @returns - True if the name ends with &quot;_len&quot;, false otherwise.
 */
export const isLen = (name: string) =&gt; /_len$/.test(name);
/**
 * Checks if a given type is felt.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type is felt, false otherwise.
 */
export const isTypeFelt = (type: string) =&gt; type === &#x27;felt&#x27; || type === &#x27;core::felt252&#x27;;
/**
 * Checks if the given type is an array type.
 *
 * @param {string} type - The type to check.
 * @returns - `true` if the type is an array type, `false` otherwise.
 */
export const isTypeArray = (type: string) =&gt;
  /\*/.test(type) ||
  type.startsWith(&#x27;core::array::Array::&#x27;) ||
  type.startsWith(&#x27;core::array::Span::&#x27;);
/**
 * Checks if the given type is a tuple type.
 *
 * @param {string} type - The type to be checked.
 * @returns - `true` if the type is a tuple type, otherwise `false`.
 */
export const isTypeTuple = (type: string) =&gt; /^\(.*\)$/i.test(type);
/**
 * Checks whether a given type is a named tuple.
 *
 * @param {string} type - The type to be checked.
 * @returns - True if the type is a named tuple, false otherwise.
 */
export const isTypeNamedTuple = (type: string) =&gt; /\(.*\)/i.test(type) &amp;&amp; type.includes(&#x27;:&#x27;);
/**
 * Checks if a given type is a struct.
 *
 * @param {string} type - The type to check for existence.
 * @param {AbiStructs} structs - The collection of structs to search in.
 * @returns - True if the type exists in the structs, false otherwise.
 */
export const isTypeStruct = (type: string, structs: AbiStructs) =&gt; type in structs;
/**
 * Checks if a given type is an enum.
 *
 * @param {string} type - The type to check.
 * @param {AbiEnums} enums - The enumeration to search in.
 * @returns - True if the type exists in the enumeration, otherwise false.
 */
export const isTypeEnum = (type: string, enums: AbiEnums) =&gt; type in enums;
/**
 * Determines if the given type is an Option type.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type is an Option type, false otherwise.
 */
export const isTypeOption = (type: string) =&gt; type.startsWith(&#x27;core::option::Option::&#x27;);
/**
 * Checks whether a given type starts with &#x27;core::result::Result::&#x27;.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type starts with &#x27;core::result::Result::&#x27;, false otherwise.
 */
export const isTypeResult = (type: string) =&gt; type.startsWith(&#x27;core::result::Result::&#x27;);
/**
 * Checks if the given value is a valid Uint type.
 *
 * @param {string} type - The value to check.
 * @returns - Returns true if the value is a valid Uint type, otherwise false.
 */
export const isTypeUint = (type: string) =&gt; Object.values(Uint).includes(type as Uint);
// Legacy Export
/**
 * Checks if the given type is `uint256`.
 *
 * @param {string} type - The type to be checked.
 * @returns - Returns true if the type is `uint256`, otherwise false.
 */
export const isTypeUint256 = (type: string) =&gt; CairoUint256.isAbiType(type);
/**
 * Checks if the given type is a literal type.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type is a literal type, false otherwise.
 */
export const isTypeLiteral = (type: string) =&gt; Object.values(Literal).includes(type as Literal);
/**
 * Checks if the given type is a boolean type.
 *
 * @param {string} type - The type to be checked.
 * @returns - Returns true if the type is a boolean type, otherwise false.
 */
export const isTypeBool = (type: string) =&gt; type === &#x27;core::bool&#x27;;
/**
 * Checks if the provided type is equal to &#x27;core::starknet::contract_address::ContractAddress&#x27;.
 * @param {string} type - The type to be checked.
 * @returns - true if the type matches &#x27;core::starknet::contract_address::ContractAddress&#x27;, false otherwise.
 */
export const isTypeContractAddress = (type: string) =&gt;
  type === &#x27;core::starknet::contract_address::ContractAddress&#x27;;
/**
 * Determines if the given type is an Ethereum address type.
 *
 * @param {string} type - The type to check.
 * @returns - Returns true if the given type is &#x27;core::starknet::eth_address::EthAddress&#x27;, otherwise false.
 */
export const isTypeEthAddress = (type: string) =&gt;
  type === &#x27;core::starknet::eth_address::EthAddress&#x27;;
/**
 * Checks if the given type is &#x27;core::bytes_31::bytes31&#x27;.
 *
 * @param {string} type - The type to check.
 * @returns - True if the type is &#x27;core::bytes_31::bytes31&#x27;, false otherwise.
 */
export const isTypeBytes31 = (type: string) =&gt; type === &#x27;core::bytes_31::bytes31&#x27;;
/**
 * Checks if the given type is equal to the &#x27;core::byte_array::ByteArray&#x27;.
 *
 * @param {string} type - The type to check.
 * @returns - True if the given type is equal to &#x27;core::byte_array::ByteArray&#x27;, false otherwise.
 */
export const isTypeByteArray = (type: string) =&gt; type === &#x27;core::byte_array::ByteArray&#x27;;
export const isTypeSecp256k1Point = (type: string) =&gt;
  type === &#x27;core::starknet::secp256k1::Secp256k1Point&#x27;;
export const isCairo1Type = (type: string) =&gt; type.includes(&#x27;::&#x27;);
/**
 * Retrieves the array type from the given type string.
 *
 * @param {string} type - The type string.
 * @returns - The array type.
 */
export const getArrayType = (type: string) =&gt; {
  if (isCairo1Type(type)) {
    return type.substring(type.indexOf(&#x27;&lt;&#x27;) + 1, type.lastIndexOf(&#x27;&gt;&#x27;));
  }
  return type.replace(&#x27;*&#x27;, &#x27;&#x27;);
};

/**
 * Test if an ABI comes from a Cairo 1 contract
 * @param abi representing the interface of a Cairo contract
 * @returns TRUE if it is an ABI from a Cairo1 contract
 * @example
 * ```typescript
 * const isCairo1: boolean = isCairo1Abi(myAbi: Abi);
 * ```
 */
export function isCairo1Abi(abi: Abi): boolean {
  const { cairo } = getAbiContractVersion(abi);
  if (cairo === undefined) {
    throw Error(&#x27;Unable to determine Cairo version&#x27;);
  }
  return cairo === &#x27;1&#x27;;
}

/**
 * Return ContractVersion (Abi version) based on Abi
 * or undefined for unknown version
 * @param abi
 * @returns string
 */
export function getAbiContractVersion(abi: Abi): ContractVersion {
  // determine by interface for &quot;Cairo 1.2&quot;
  if (abi.find((it) =&gt; it.type === &#x27;interface&#x27;)) {
    return { cairo: &#x27;1&#x27;, compiler: &#x27;2&#x27; };
  }

  // determine by function io types &quot;Cairo 1.1&quot; or &quot;Cairo 0.0&quot;
  // find first function with inputs or outputs
  const testFunction = abi.find(
    (it) =&gt; it.type === &#x27;function&#x27; &amp;&amp; (it.inputs.length || it.outputs.length)
  );
  if (!testFunction) {
    return { cairo: undefined, compiler: undefined };
  }
  const io = testFunction.inputs.length ? testFunction.inputs : testFunction.outputs;
  if (isCairo1Type(io[0].type)) {
    return { cairo: &#x27;1&#x27;, compiler: &#x27;1&#x27; };
  }
  return { cairo: &#x27;0&#x27;, compiler: &#x27;0&#x27; };
}

/**
 * named tuple cairo type is described as js object {}
 * struct cairo type are described as js object {}
 * array cairo type are described as js array []
 */

/**
 * Create Uint256 Cairo type (helper for common struct type)
 * @example
 * ```typescript
 * uint256(&#x27;892349863487563453485768723498&#x27;);
 * ```
 */
export const uint256 = (it: BigNumberish): Uint256 =&gt; {
  return new CairoUint256(it).toUint256DecimalString();
};

/**
 * Create Uint512 Cairo type (helper for common struct type)
 * @param it BigNumberish representation of a 512 bits unsigned number
 * @returns Uint512 struct
 * @example
 * ```typescript
 * uint512(&#x27;345745685892349863487563453485768723498&#x27;);
 * ```
 */
export const uint512 = (it: BigNumberish): Uint512 =&gt; {
  return new CairoUint512(it).toUint512DecimalString();
};

/**
 * Create unnamed tuple Cairo type (helper same as common struct type)
 * @example
 * ```typescript
 * tuple(1, &#x27;0x101&#x27;, 16);
 * ```
 */
export const tuple = (
  ...args: (BigNumberish | object | boolean)[]
): Record&lt;number, BigNumberish | object | boolean&gt; =&gt; ({ ...args });

/**
 * Create felt Cairo type (cairo type helper)
 * @returns format: felt-string
 */
export function felt(it: BigNumberish): string {
  return CairoFelt(it);
}
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:183,&quot;character&quot;:16,&quot;text&quot;:&quot;it&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:183,&quot;character&quot;:23,&quot;text&quot;:&quot;it&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:183,&quot;character&quot;:26,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:189,&quot;character&quot;:8,&quot;text&quot;:&quot;testFunction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:5,&quot;text&quot;:&quot;it&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:12,&quot;text&quot;:&quot;it&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:15,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:39,&quot;text&quot;:&quot;it&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:42,&quot;text&quot;:&quot;inputs&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:49,&quot;text&quot;:&quot;length&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:59,&quot;text&quot;:&quot;it&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:62,&quot;text&quot;:&quot;outputs&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:70,&quot;text&quot;:&quot;length&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:192,&quot;character&quot;:7,&quot;text&quot;:&quot;testFunction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:8,&quot;text&quot;:&quot;io&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:13,&quot;text&quot;:&quot;testFunction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:26,&quot;text&quot;:&quot;inputs&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:33,&quot;text&quot;:&quot;length&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:42,&quot;text&quot;:&quot;testFunction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:55,&quot;text&quot;:&quot;inputs&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:64,&quot;text&quot;:&quot;testFunction&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:195,&quot;character&quot;:77,&quot;text&quot;:&quot;outputs&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:196,&quot;character&quot;:19,&quot;text&quot;:&quot;io&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/calldata/cairo.ts&quot;,&quot;line&quot;:196,&quot;character&quot;:25,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Apr 2024 15:57:37 GMT</p>
    </body>
  </html>
  