
  <!DOCTYPE html>
  <html>
    <head>
      <title>num.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/utils/num.ts</td><td class="">98.76%</td><td class="">80%</td><td class="">161</td><td class="">159</td><td class="">2</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { hexToBytes as hexToBytesNoble } from &#x27;@noble/curves/abstract/utils&#x27;;

import { BigNumberish } from &#x27;../types&#x27;;
import assert from &#x27;./assert&#x27;;
import { addHexPrefix, removeHexPrefix } from &#x27;./encode&#x27;;

/** @deprecated prefer importing from &#x27;types&#x27; over &#x27;num&#x27; */
export type { BigNumberish };

/**
 * Test if string is hex-string
 * @param hex hex-string
 */
export function isHex(hex: string): boolean {
  return /^0x[0-9a-f]*$/i.test(hex);
}

/**
 * Convert BigNumberish to bigint
 */
export function toBigInt(value: BigNumberish): bigint {
  return BigInt(value);
}

/**
 * Test if value is bigint
 */
export function isBigInt(value: any): value is bigint {
  return typeof value === &#x27;bigint&#x27;;
}

/**
 * Convert BigNumberish to hex-string
 * @returns format: hex-string
 */
export function toHex(number: BigNumberish): string {
  return addHexPrefix(toBigInt(number).toString(16));
}

/**
 * Alias of ToHex
 */
export const toHexString = toHex;

/**
 * Convert BigNumberish to storage-key-string
 *
 * Same as toHex but conforming to the STORAGE_KEY pattern `^0x0[0-7]{1}[a-fA-F0-9]{0,62}$`.
 *
 * A storage key is represented as up to 62 hex digits, 3 bits, and 5 leading zeroes:
 * `0x0 + [0-7] + 62 hex = 0x + 64 hex`
 * @returns format: storage-key-string
 */
export function toStorageKey(number: BigNumberish): string {
  const res = addHexPrefix(toBigInt(number).toString(16).padStart(64, &#x27;0&#x27;));
  return res;
}

/**
 * Convert hexadecimal string to decimal string
 * @param hex hex-string
 * @returns format: decimal string
 */
export function hexToDecimalString(hex: string): string {
  return BigInt(addHexPrefix(hex)).toString(10);
}

/**
 * Remove hex string leading zero and lowercase it
 * @example &#x27;0x01A...&#x27; -&gt; &#x27;0x1a..&#x27;
 * @param hex hex-string
 * @returns format: hex-string
 */
export const cleanHex = (hex: string) =&gt; hex.toLowerCase().replace(/^(0x)0+/, &#x27;$1&#x27;);

/**
 * Asserts input is equal to or greater then lowerBound and lower then upperBound.
 *
 * The `inputName` parameter is used in the assertion message.
 */
export function assertInRange(
  input: BigNumberish,
  lowerBound: BigNumberish,
  upperBound: BigNumberish,
  inputName = &#x27;&#x27;
) {
  const messageSuffix = inputName === &#x27;&#x27; ? &#x27;invalid length&#x27; : `invalid ${inputName} length`;
  const inputBigInt = BigInt(input);
  const lowerBoundBigInt = BigInt(lowerBound);
  const upperBoundBigInt = BigInt(upperBound);

  assert(
    inputBigInt &gt;= lowerBoundBigInt &amp;&amp; inputBigInt &lt;= upperBoundBigInt,
    `Message not signable, ${messageSuffix}.`
  );
}

/**
 * Convert BigNumberish array to decimal string array
 * @returns format: decimal string array
 */
export function bigNumberishArrayToDecimalStringArray(rawCalldata: BigNumberish[]): string[] {
  return rawCalldata.map((x) =&gt; toBigInt(x).toString(10));
}

/**
 * Convert BigNumberish array to hexadecimal string array
 * @returns format: hex-string array
 */
export function bigNumberishArrayToHexadecimalStringArray(rawCalldata: BigNumberish[]): string[] {
  return rawCalldata.map((x) =&gt; toHex(x));
}

/**
 * Test if string is whole number (0, 1, 2, 3...)
 */
export const isStringWholeNumber = (value: string) =&gt; /^\d+$/.test(value);

/**
 * Convert string to decimal string
 * @returns format: decimal string
 */
export function getDecimalString(value: string) {
  if (isHex(value)) {
    return hexToDecimalString(value);
  }
  if (isStringWholeNumber(value)) {
    return value;
  }
  throw new Error(`${value} need to be hex-string or whole-number-string`);
}

/**
 * Convert string to hexadecimal string
 * @returns format: hex-string
 */
export function getHexString(value: string) {
  if (isHex(value)) {
    return value;
  }
  if (isStringWholeNumber(value)) {
    return toHexString(value);
  }
  throw new Error(`${value} need to be hex-string or whole-number-string`);
}

/**
 * Convert string array to hex-string array
 * @returns format: hex-string array
 */
export function getHexStringArray(value: Array&lt;string&gt;) {
  return value.map((el) =&gt; getHexString(el));
}

/**
 * Convert boolean to &quot;0&quot; or &quot;1&quot;
 */
export const toCairoBool = (value: boolean): string =&gt; (+value).toString();

/**
 * Convert hex-string to an array of Bytes (Uint8Array)
 * @param value hex-string
 */
export function hexToBytes(value: string): Uint8Array {
  if (!isHex(value)) throw new Error(`${value} need to be a hex-string`);

  let adaptedValue: string = removeHexPrefix(value);
  if (adaptedValue.length % 2 !== 0) {
    adaptedValue = `0${adaptedValue}`;
  }
  return hexToBytesNoble(adaptedValue);
}

/**
 *
 * @param number value to be increased
 * @param percent integer as percent ex. 50 for 50%
 * @returns increased value
 */
export function addPercent(number: BigNumberish, percent: number) {
  const bigIntNum = BigInt(number);
  return bigIntNum + (bigIntNum * BigInt(percent)) / 100n;
}

/**
 * Check if a value is a number.
 *
 * @param {unknown} value - The value to check.
 * @return {boolean} Returns true if the value is a number, otherwise returns false.
 */
export function isNumber(value: unknown): value is number {
  return typeof value === &#x27;number&#x27;;
}

/**
 * Checks if a given value is of boolean type.
 *
 * @param {unknown} value - The value to check.
 * @return {boolean} - True if the value is of boolean type, false otherwise.
 */
export function isBoolean(value: unknown): value is boolean {
  return typeof value === &#x27;boolean&#x27;;
}
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/utils/num.ts&quot;,&quot;line&quot;:27,&quot;character&quot;:25,&quot;text&quot;:&quot;value&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/utils/num.ts&quot;,&quot;line&quot;:28,&quot;character&quot;:16,&quot;text&quot;:&quot;value&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Apr 2024 15:57:37 GMT</p>
    </body>
  </html>
  