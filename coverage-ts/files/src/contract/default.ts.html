
  <!DOCTYPE html>
  <html>
    <head>
      <title>default.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/contract/default.ts</td><td class="">98.09%</td><td class="">80%</td><td class="">576</td><td class="">565</td><td class="">11</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import type { Abi as AbiKanabi, TypedContract as AbiWanTypedContract } from &#x27;abi-wan-kanabi&#x27;;

import { AccountInterface } from &#x27;../account&#x27;;
import { ProviderInterface, defaultProvider } from &#x27;../provider&#x27;;
import {
  Abi,
  AbiEvents,
  ArgsOrCalldata,
  ArgsOrCalldataWithOptions,
  AsyncContractFunction,
  Call,
  CallOptions,
  Calldata,
  ContractFunction,
  ContractOptions,
  EstimateFeeResponse,
  FunctionAbi,
  InvokeFunctionResponse,
  InvokeOptions,
  InvokeTransactionReceiptResponse,
  ParsedEvents,
  RawArgs,
  Result,
  StructAbi,
  ValidateType,
} from &#x27;../types&#x27;;
import assert from &#x27;../utils/assert&#x27;;
import { CallData, cairo } from &#x27;../utils/calldata&#x27;;
import { createAbiParser } from &#x27;../utils/calldata/parser&#x27;;
import { getAbiEvents, parseEvents as parseRawEvents } from &#x27;../utils/events/index&#x27;;
import { cleanHex } from &#x27;../utils/num&#x27;;
import { ContractInterface } from &#x27;./interface&#x27;;
import type { GetTransactionReceiptResponse } from &#x27;../utils/transactionReceipt&#x27;;

export type TypedContractV2&lt;TAbi extends AbiKanabi&gt; = AbiWanTypedContract&lt;TAbi&gt; &amp; Contract;

export const splitArgsAndOptions = (args: ArgsOrCalldataWithOptions) =&gt; {
  const options = [
    &#x27;blockIdentifier&#x27;,
    &#x27;parseRequest&#x27;,
    &#x27;parseResponse&#x27;,
    &#x27;formatResponse&#x27;,
    &#x27;maxFee&#x27;,
    &#x27;nonce&#x27;,
    &#x27;signature&#x27;,
    &#x27;addressSalt&#x27;,
  ];
  const lastArg = args[args.length - 1];
  if (typeof lastArg === &#x27;object&#x27; &amp;&amp; options.some((x) =&gt; x in lastArg)) {
    return { args: args as ArgsOrCalldata, options: args.pop() as ContractOptions };
  }
  return { args: args as ArgsOrCalldata };
};

/**
 * Adds call methods to the contract
 */
function buildCall(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {
  return async function (...args: ArgsOrCalldataWithOptions): Promise&lt;any&gt; {
    const params = splitArgsAndOptions(args);
    return contract.call(functionAbi.name, params.args, {
      parseRequest: true,
      parseResponse: true,
      ...params.options,
    });
  };
}

/**
 * Adds invoke methods to the contract
 */
function buildInvoke(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {
  return async function (...args: Array&lt;any&gt;): Promise&lt;any&gt; {
    const params = splitArgsAndOptions(args);
    return contract.invoke(functionAbi.name, params.args, {
      parseRequest: true,
      ...params.options,
    });
  };
}

/**
 * Adds call/invoke methods to the contract
 */
function buildDefault(contract: Contract, functionAbi: FunctionAbi): AsyncContractFunction {
  if (functionAbi.stateMutability === &#x27;view&#x27; || functionAbi.state_mutability === &#x27;view&#x27;) {
    return buildCall(contract, functionAbi);
  }
  return buildInvoke(contract, functionAbi);
}

/**
 * Adds populate for methods to the contract
 */
function buildPopulate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {
  return function (...args: Array&lt;any&gt;): any {
    return contract.populate(functionAbi.name, args);
  };
}

/**
 * Adds estimateFee for methods to the contract
 */
function buildEstimate(contract: Contract, functionAbi: FunctionAbi): ContractFunction {
  return function (...args: Array&lt;any&gt;): any {
    return contract.estimate(functionAbi.name, args);
  };
}

export function getCalldata(args: RawArgs, callback: Function): Calldata {
  // Check if Calldata in args or args[0] else compile
  if (Array.isArray(args) &amp;&amp; &#x27;__compiled__&#x27; in args) return args as Calldata;
  if (Array.isArray(args) &amp;&amp; Array.isArray(args[0]) &amp;&amp; &#x27;__compiled__&#x27; in args[0])
    return args[0] as Calldata;
  return callback();
}

export class Contract implements ContractInterface {
  abi: Abi;

  address: string;

  providerOrAccount: ProviderInterface | AccountInterface;

  deployTransactionHash?: string;

  protected readonly structs: { [name: string]: StructAbi };

  protected readonly events: AbiEvents;

  readonly functions!: { [name: string]: AsyncContractFunction };

  readonly callStatic!: { [name: string]: AsyncContractFunction };

  readonly populateTransaction!: { [name: string]: ContractFunction };

  readonly estimateFee!: { [name: string]: ContractFunction };

  readonly [key: string]: AsyncContractFunction | any;

  private callData: CallData;

  /**
   * Contract class to handle contract methods
   *
   * @param abi - Abi of the contract object
   * @param address (optional) - address to connect to
   * @param providerOrAccount (optional) - Provider or Account to attach to
   */
  constructor(
    abi: Abi,
    address: string,
    providerOrAccount: ProviderInterface | AccountInterface = defaultProvider
  ) {
    this.address = address &amp;&amp; address.toLowerCase();
    this.providerOrAccount = providerOrAccount;
    this.callData = new CallData(abi);
    this.structs = CallData.getAbiStruct(abi);
    this.events = getAbiEvents(abi);
    const parser = createAbiParser(abi);
    this.abi = parser.getLegacyFormat();

    const options = { enumerable: true, value: {}, writable: false };
    Object.defineProperties(this, {
      functions: { enumerable: true, value: {}, writable: false },
      callStatic: { enumerable: true, value: {}, writable: false },
      populateTransaction: { enumerable: true, value: {}, writable: false },
      estimateFee: { enumerable: true, value: {}, writable: false },
    });
    this.abi.forEach((abiElement) =&gt; {
      if (abiElement.type !== &#x27;function&#x27;) return;
      const signature = abiElement.name;
      if (!this[signature]) {
        Object.defineProperty(this, signature, {
          ...options,
          value: buildDefault(this, abiElement),
        });
      }
      if (!this.functions[signature]) {
        Object.defineProperty(this.functions, signature, {
          ...options,
          value: buildDefault(this, abiElement),
        });
      }
      if (!this.callStatic[signature]) {
        Object.defineProperty(this.callStatic, signature, {
          ...options,
          value: buildCall(this, abiElement),
        });
      }
      if (!this.populateTransaction[signature]) {
        Object.defineProperty(this.populateTransaction, signature, {
          ...options,
          value: buildPopulate(this, abiElement),
        });
      }
      if (!this.estimateFee[signature]) {
        Object.defineProperty(this.estimateFee, signature, {
          ...options,
          value: buildEstimate(this, abiElement),
        });
      }
    });
  }

  public attach(address: string): void {
    this.address = address;
  }

  public connect(providerOrAccount: ProviderInterface | AccountInterface) {
    this.providerOrAccount = providerOrAccount;
  }

  public async deployed(): Promise&lt;Contract&gt; {
    if (this.deployTransactionHash) {
      await this.providerOrAccount.waitForTransaction(this.deployTransactionHash);
      this.deployTransactionHash = undefined;
    }
    return this;
  }

  public async call(
    method: string,
    args: ArgsOrCalldata = [],
    {
      parseRequest = true,
      parseResponse = true,
      formatResponse = undefined,
      blockIdentifier = undefined,
    }: CallOptions = {}
  ): Promise&lt;Result&gt; {
    assert(this.address !== null, &#x27;contract is not connected to an address&#x27;);

    const calldata = getCalldata(args, () =&gt; {
      if (parseRequest) {
        this.callData.validate(ValidateType.CALL, method, args);
        return this.callData.compile(method, args);
      }
      // eslint-disable-next-line no-console
      console.warn(&#x27;Call skipped parsing but provided rawArgs, possible malfunction request&#x27;);
      return args;
    });

    return this.providerOrAccount
      .callContract(
        {
          contractAddress: this.address,
          calldata,
          entrypoint: method,
        },
        blockIdentifier
      )
      .then((it) =&gt; {
        if (!parseResponse) {
          return it;
        }
        if (formatResponse) {
          return this.callData.format(method, it, formatResponse);
        }
        return this.callData.parse(method, it);
      });
  }

  public invoke(
    method: string,
    args: ArgsOrCalldata = [],
    { parseRequest = true, maxFee, nonce, signature }: InvokeOptions = {}
  ): Promise&lt;InvokeFunctionResponse&gt; {
    assert(this.address !== null, &#x27;contract is not connected to an address&#x27;);

    const calldata = getCalldata(args, () =&gt; {
      if (parseRequest) {
        this.callData.validate(ValidateType.INVOKE, method, args);
        return this.callData.compile(method, args);
      }
      // eslint-disable-next-line no-console
      console.warn(&#x27;Invoke skipped parsing but provided rawArgs, possible malfunction request&#x27;);
      return args;
    });

    const invocation = {
      contractAddress: this.address,
      calldata,
      entrypoint: method,
    };
    if (&#x27;execute&#x27; in this.providerOrAccount) {
      return this.providerOrAccount.execute(invocation, undefined, {
        maxFee,
        nonce,
      });
    }

    if (!nonce) throw new Error(`Nonce is required when invoking a function without an account`);
    // eslint-disable-next-line no-console
    console.warn(`Invoking ${method} without an account. This will not work on a public node.`);

    return this.providerOrAccount.invokeFunction(
      {
        ...invocation,
        signature,
      },
      {
        nonce,
      }
    );
  }

  public async estimate(method: string, args: ArgsOrCalldata = []): Promise&lt;EstimateFeeResponse&gt; {
    assert(this.address !== null, &#x27;contract is not connected to an address&#x27;);

    if (!getCalldata(args, () =&gt; false)) {
      this.callData.validate(ValidateType.INVOKE, method, args);
    }

    const invocation = this.populate(method, args);
    if (&#x27;estimateInvokeFee&#x27; in this.providerOrAccount) {
      return this.providerOrAccount.estimateInvokeFee(invocation);
    }
    throw Error(&#x27;Contract must be connected to the account contract to estimate&#x27;);
  }

  public populate(method: string, args: RawArgs = []): Call {
    const calldata: Calldata = getCalldata(args, () =&gt; this.callData.compile(method, args));
    return {
      contractAddress: this.address,
      entrypoint: method,
      calldata,
    };
  }

  public parseEvents(receipt: GetTransactionReceiptResponse): ParsedEvents {
    return parseRawEvents(
      (receipt as InvokeTransactionReceiptResponse).events?.filter(
        (event) =&gt; cleanHex(event.from_address) === cleanHex(this.address),
        []
      ) || [],
      this.events,
      this.structs,
      CallData.getAbiEnum(this.abi)
    );
  }

  public isCairo1(): boolean {
    return cairo.isCairo1Abi(this.abi);
  }

  public async getVersion() {
    return this.providerOrAccount.getContractVersion(this.address);
  }

  public typedv2&lt;TAbi extends AbiKanabi&gt;(tAbi: TAbi): TypedContractV2&lt;TAbi&gt; {
    return this as unknown as TypedContractV2&lt;typeof tAbi&gt;;
  }
}
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:169,&quot;character&quot;:22,&quot;text&quot;:&quot;abiElement&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:170,&quot;character&quot;:10,&quot;text&quot;:&quot;abiElement&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:170,&quot;character&quot;:21,&quot;text&quot;:&quot;type&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:171,&quot;character&quot;:12,&quot;text&quot;:&quot;signature&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:171,&quot;character&quot;:24,&quot;text&quot;:&quot;abiElement&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:171,&quot;character&quot;:35,&quot;text&quot;:&quot;name&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:172,&quot;character&quot;:16,&quot;text&quot;:&quot;signature&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:178,&quot;character&quot;:26,&quot;text&quot;:&quot;signature&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:184,&quot;character&quot;:27,&quot;text&quot;:&quot;signature&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:190,&quot;character&quot;:36,&quot;text&quot;:&quot;signature&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/contract/default.ts&quot;,&quot;line&quot;:196,&quot;character&quot;:28,&quot;text&quot;:&quot;signature&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Apr 2024 15:57:38 GMT</p>
    </body>
  </html>
  