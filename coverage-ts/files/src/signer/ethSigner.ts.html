
  <!DOCTYPE html>
  <html>
    <head>
      <title>ethSigner.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/signer/ethSigner.ts</td><td class="">97.12%</td><td class="">80%</td><td class="">312</td><td class="">303</td><td class="">9</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import type { RecoveredSignatureType } from &#x27;@noble/curves/abstract/weierstrass&#x27;;
import { secp256k1 } from &#x27;@noble/curves/secp256k1&#x27;;

import {
  ArraySignatureType,
  Call,
  DeclareSignerDetails,
  DeployAccountSignerDetails,
  InvocationsSignerDetails,
  Signature,
  TypedData,
  Uint256,
  V2DeclareSignerDetails,
  V2DeployAccountSignerDetails,
  V2InvocationsSignerDetails,
  V3DeclareSignerDetails,
  V3DeployAccountSignerDetails,
  V3InvocationsSignerDetails,
} from &#x27;../types&#x27;;
import { ETransactionVersion2, ETransactionVersion3 } from &#x27;../types/api&#x27;;
import { CallData } from &#x27;../utils/calldata&#x27;;
import { addHexPrefix, buf2hex, removeHexPrefix, sanitizeHex } from &#x27;../utils/encode&#x27;;
import { ethRandomPrivateKey } from &#x27;../utils/eth&#x27;;
import {
  calculateDeclareTransactionHash,
  calculateDeployAccountTransactionHash,
  calculateInvokeTransactionHash,
} from &#x27;../utils/hash&#x27;;
import { toHex } from &#x27;../utils/num&#x27;;
import { intDAM } from &#x27;../utils/stark&#x27;;
import { getExecuteCalldata } from &#x27;../utils/transaction&#x27;;
import { getMessageHash } from &#x27;../utils/typedData&#x27;;
import { bnToUint256 } from &#x27;../utils/uint256&#x27;;
import { SignerInterface } from &#x27;./interface&#x27;;

/**
 * Signer for accounts using Ethereum signature
 */
export class EthSigner implements SignerInterface {
  protected pk: string; // hex string without 0x and with an odd number of characters

  constructor(pk: Uint8Array | string = ethRandomPrivateKey()) {
    this.pk =
      pk instanceof Uint8Array
        ? buf2hex(pk).padStart(64, &#x27;0&#x27;)
        : removeHexPrefix(toHex(pk)).padStart(64, &#x27;0&#x27;);
  }

  /**
   * provides the Ethereum full public key (without parity prefix)
   * @returns an hex string : 64 first characters are Point X coordinate. 64 last characters are Point Y coordinate.
   */
  public async getPubKey(): Promise&lt;string&gt; {
    return addHexPrefix(
      buf2hex(secp256k1.getPublicKey(this.pk, false)).padStart(130, &#x27;0&#x27;).slice(2)
    );
  }

  public async signMessage(typedData: TypedData, accountAddress: string): Promise&lt;Signature&gt; {
    const msgHash = getMessageHash(typedData, accountAddress);
    const signature: RecoveredSignatureType = secp256k1.sign(
      removeHexPrefix(sanitizeHex(msgHash)),
      this.pk
    );
    return this.formatEthSignature(signature);
  }

  public async signTransaction(
    transactions: Call[],
    details: InvocationsSignerDetails
  ): Promise&lt;Signature&gt; {
    const compiledCalldata = getExecuteCalldata(transactions, details.cairoVersion);
    let msgHash;

    // TODO: How to do generic union discriminator for all like this
    if (Object.values(ETransactionVersion2).includes(details.version as any)) {
      const det = details as V2InvocationsSignerDetails;
      msgHash = calculateInvokeTransactionHash({
        ...det,
        senderAddress: det.walletAddress,
        compiledCalldata,
        version: det.version,
      });
    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {
      const det = details as V3InvocationsSignerDetails;
      msgHash = calculateInvokeTransactionHash({
        ...det,
        senderAddress: det.walletAddress,
        compiledCalldata,
        version: det.version,
        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),
      });
    } else {
      throw Error(&#x27;unsupported signTransaction version&#x27;);
    }
    const signature: RecoveredSignatureType = secp256k1.sign(
      removeHexPrefix(sanitizeHex(msgHash)),
      this.pk
    );
    return this.formatEthSignature(signature);
  }

  public async signDeployAccountTransaction(
    details: DeployAccountSignerDetails
  ): Promise&lt;Signature&gt; {
    const compiledConstructorCalldata = CallData.compile(details.constructorCalldata);
    /*     const version = BigInt(details.version).toString(); */
    let msgHash;

    if (Object.values(ETransactionVersion2).includes(details.version as any)) {
      const det = details as V2DeployAccountSignerDetails;
      msgHash = calculateDeployAccountTransactionHash({
        ...det,
        salt: det.addressSalt,
        constructorCalldata: compiledConstructorCalldata,
        version: det.version,
      });
    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {
      const det = details as V3DeployAccountSignerDetails;
      msgHash = calculateDeployAccountTransactionHash({
        ...det,
        salt: det.addressSalt,
        compiledConstructorCalldata,
        version: det.version,
        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),
      });
    } else {
      throw Error(&#x27;unsupported signDeployAccountTransaction version&#x27;);
    }
    const signature: RecoveredSignatureType = secp256k1.sign(
      removeHexPrefix(sanitizeHex(msgHash)),
      this.pk
    );
    return this.formatEthSignature(signature);
  }

  public async signDeclareTransaction(
    // contractClass: ContractClass,  // Should be used once class hash is present in ContractClass
    details: DeclareSignerDetails
  ): Promise&lt;Signature&gt; {
    let msgHash;

    if (Object.values(ETransactionVersion2).includes(details.version as any)) {
      const det = details as V2DeclareSignerDetails;
      msgHash = calculateDeclareTransactionHash({
        ...det,
        version: det.version,
      });
    } else if (Object.values(ETransactionVersion3).includes(details.version as any)) {
      const det = details as V3DeclareSignerDetails;
      msgHash = calculateDeclareTransactionHash({
        ...det,
        version: det.version,
        nonceDataAvailabilityMode: intDAM(det.nonceDataAvailabilityMode),
        feeDataAvailabilityMode: intDAM(det.feeDataAvailabilityMode),
      });
    } else {
      throw Error(&#x27;unsupported signDeclareTransaction version&#x27;);
    }

    const signature: RecoveredSignatureType = secp256k1.sign(
      removeHexPrefix(sanitizeHex(msgHash)),
      this.pk
    );
    return this.formatEthSignature(signature);
  }

  /**
   * Serialize the signature in conformity with starknet::eth_signature::Signature
   * @param ethSignature secp256k1 signature from Noble curves library
   * @return an array of felts, representing a Cairo Eth Signature.
   */
  protected formatEthSignature(ethSignature: RecoveredSignatureType): ArraySignatureType {
    const r: Uint256 = bnToUint256(ethSignature.r);
    const s: Uint256 = bnToUint256(ethSignature.s);
    return [
      toHex(r.low),
      toHex(r.high),
      toHex(s.low),
      toHex(s.high),
      toHex(ethSignature.recovery),
    ] as ArraySignatureType;
  }
}
</textarea><pre id="annotations" style="display:none">[{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:72,&quot;character&quot;:8,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:77,&quot;character&quot;:6,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:85,&quot;character&quot;:6,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:108,&quot;character&quot;:8,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:112,&quot;character&quot;:6,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:120,&quot;character&quot;:6,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:142,&quot;character&quot;:8,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:146,&quot;character&quot;:6,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1},{&quot;file&quot;:&quot;src/signer/ethSigner.ts&quot;,&quot;line&quot;:152,&quot;character&quot;:6,&quot;text&quot;:&quot;msgHash&quot;,&quot;kind&quot;:1}]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Apr 2024 15:57:37 GMT</p>
    </body>
  </html>
  