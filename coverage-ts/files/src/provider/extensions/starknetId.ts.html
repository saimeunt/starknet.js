
  <!DOCTYPE html>
  <html>
    <head>
      <title>starknetId.ts</title>
      <link href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css" type="text/css" rel="stylesheet">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.js" type="text/javascript" charset="utf-8"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/mode/javascript/javascript.min.js" type="text/javascript" charset="utf-8"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.2/codemirror.min.css" type="text/css" rel="stylesheet">
<script src="../../../../assets/source-file.js" type="text/javascript" charset="utf-8"></script>
<link href="../../../../assets/source-file.css" type="text/css" rel="stylesheet">
    </head>
    <body>
    <div style="margin-top:3em" class="ui container"><h1 class="ui header"><a href="../../../../index.html">TypeScript coverage report</a></h1><table style="margin-top:2em" class="ui celled table"><thead class=""><tr class=""><th class="">Filename</th><th class="">Percent</th><th class="">Threshold</th><th class="">Total</th><th class="">Covered</th><th class="">Uncovered</th></tr></thead><tbody class=""><tr class="positive"><td class="">src/provider/extensions/starknetId.ts</td><td class="">100.00%</td><td class="">80%</td><td class="">405</td><td class="">405</td><td class="">0</td></tr></tbody></table><textarea id="editor" readonly="" style="margin-top:3em">import { BigNumberish, StarkProfile } from &#x27;../../types&#x27;;
import { CallData } from &#x27;../../utils/calldata&#x27;;
import { getSelectorFromName } from &#x27;../../utils/hash&#x27;;
import { decodeShortString, encodeShortString } from &#x27;../../utils/shortString&#x27;;
import {
  dynamicCallData,
  dynamicFelt,
  execution,
  getStarknetIdContract,
  getStarknetIdIdentityContract,
  getStarknetIdMulticallContract,
  getStarknetIdPfpContract,
  getStarknetIdPopContract,
  getStarknetIdVerifierContract,
  useDecoded,
  useEncoded,
} from &#x27;../../utils/starknetId&#x27;;
import type { ProviderInterface } from &#x27;..&#x27;;

export class StarknetId {
  async getStarkName(address: BigNumberish, StarknetIdContract?: string) {
    return StarknetId.getStarkName(
      // After Mixin, this is ProviderInterface
      (&lt;unknown&gt;this) as ProviderInterface,
      address,
      StarknetIdContract
    );
  }

  public async getAddressFromStarkName(name: string, StarknetIdContract?: string): Promise&lt;string&gt; {
    return StarknetId.getAddressFromStarkName(
      // After Mixin, this is ProviderInterface
      (&lt;unknown&gt;this) as ProviderInterface,
      name,
      StarknetIdContract
    );
  }

  async getStarkProfile(
    address: BigNumberish,
    StarknetIdContract?: string,
    StarknetIdIdentityContract?: string,
    StarknetIdVerifierContract?: string,
    StarknetIdPfpContract?: string,
    StarknetIdPopContract?: string,
    StarknetIdMulticallContract?: string
  ) {
    return StarknetId.getStarkProfile(
      // After Mixin, this is ProviderInterface
      (&lt;unknown&gt;this) as ProviderInterface,
      address,
      StarknetIdContract,
      StarknetIdIdentityContract,
      StarknetIdVerifierContract,
      StarknetIdPfpContract,
      StarknetIdPopContract,
      StarknetIdMulticallContract
    );
  }

  static async getStarkName(
    provider: ProviderInterface,
    address: BigNumberish,
    StarknetIdContract?: string
  ): Promise&lt;string&gt; {
    const chainId = await provider.getChainId();
    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);

    try {
      const hexDomain = await provider.callContract({
        contractAddress: contract,
        entrypoint: &#x27;address_to_domain&#x27;,
        calldata: CallData.compile({
          address,
        }),
      });
      const decimalDomain = hexDomain.map((element) =&gt; BigInt(element)).slice(1);

      const stringDomain = useDecoded(decimalDomain);

      if (!stringDomain) {
        throw Error(&#x27;Starkname not found&#x27;);
      }

      return stringDomain;
    } catch (e) {
      if (e instanceof Error &amp;&amp; e.message === &#x27;Starkname not found&#x27;) {
        throw e;
      }
      throw Error(&#x27;Could not get stark name&#x27;);
    }
  }

  static async getAddressFromStarkName(
    provider: ProviderInterface,
    name: string,
    StarknetIdContract?: string
  ): Promise&lt;string&gt; {
    const chainId = await provider.getChainId();
    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);

    try {
      const encodedDomain = name
        .replace(&#x27;.stark&#x27;, &#x27;&#x27;)
        .split(&#x27;.&#x27;)
        .map((part) =&gt; useEncoded(part).toString(10));

      const addressData = await provider.callContract({
        contractAddress: contract,
        entrypoint: &#x27;domain_to_address&#x27;,
        calldata: CallData.compile({ domain: encodedDomain, hint: [] }),
      });

      return addressData[0];
    } catch {
      throw Error(&#x27;Could not get address from stark name&#x27;);
    }
  }

  static async getStarkProfile(
    provider: ProviderInterface,
    address: BigNumberish,
    StarknetIdContract?: string,
    StarknetIdIdentityContract?: string,
    StarknetIdVerifierContract?: string,
    StarknetIdPfpContract?: string,
    StarknetIdPopContract?: string,
    StarknetIdMulticallContract?: string
  ): Promise&lt;StarkProfile&gt; {
    const chainId = await provider.getChainId();
    const contract = StarknetIdContract ?? getStarknetIdContract(chainId);
    const identityContract = StarknetIdIdentityContract ?? getStarknetIdIdentityContract(chainId);
    const verifierContract = StarknetIdVerifierContract ?? getStarknetIdVerifierContract(chainId);
    const pfpContract = StarknetIdPfpContract ?? getStarknetIdPfpContract(chainId);
    const popContract = StarknetIdPopContract ?? getStarknetIdPopContract(chainId);
    const multicallAddress = StarknetIdMulticallContract ?? getStarknetIdMulticallContract(chainId);

    try {
      const data = await provider.callContract({
        contractAddress: multicallAddress,
        entrypoint: &#x27;aggregate&#x27;,
        calldata: CallData.compile({
          calls: [
            {
              execution: execution({}),
              to: dynamicFelt(contract),
              selector: dynamicFelt(getSelectorFromName(&#x27;address_to_domain&#x27;)),
              calldata: [dynamicCallData(address)],
            },
            {
              execution: execution({}),
              to: dynamicFelt(contract),
              selector: dynamicFelt(getSelectorFromName(&#x27;domain_to_id&#x27;)),
              calldata: [dynamicCallData(undefined, undefined, [0, 0])],
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName(&#x27;get_verifier_data&#x27;)),
              calldata: [
                dynamicCallData(undefined, [1, 0]),
                dynamicCallData(encodeShortString(&#x27;twitter&#x27;)),
                dynamicCallData(verifierContract),
                dynamicCallData(&#x27;0&#x27;),
              ],
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName(&#x27;get_verifier_data&#x27;)),
              calldata: [
                dynamicCallData(undefined, [1, 0]),
                dynamicCallData(encodeShortString(&#x27;github&#x27;)),
                dynamicCallData(verifierContract),
                dynamicCallData(&#x27;0&#x27;),
              ],
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName(&#x27;get_verifier_data&#x27;)),
              calldata: [
                dynamicCallData(undefined, [1, 0]),
                dynamicCallData(encodeShortString(&#x27;discord&#x27;)),
                dynamicCallData(verifierContract),
                dynamicCallData(&#x27;0&#x27;),
              ],
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName(&#x27;get_verifier_data&#x27;)),
              calldata: [
                dynamicCallData(undefined, [1, 0]),
                dynamicCallData(encodeShortString(&#x27;proof_of_personhood&#x27;)),
                dynamicCallData(popContract),
                dynamicCallData(&#x27;0&#x27;),
              ],
            },
            // PFP
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName(&#x27;get_verifier_data&#x27;)),
              calldata: [
                dynamicCallData(undefined, [1, 0]),
                dynamicCallData(encodeShortString(&#x27;nft_pp_contract&#x27;)),
                dynamicCallData(pfpContract),
                dynamicCallData(&#x27;0&#x27;),
              ],
            },
            {
              execution: execution({}),
              to: dynamicFelt(identityContract),
              selector: dynamicFelt(getSelectorFromName(&#x27;get_extended_verifier_data&#x27;)),
              calldata: [
                dynamicCallData(undefined, [1, 0]),
                dynamicCallData(encodeShortString(&#x27;nft_pp_id&#x27;)),
                dynamicCallData(&#x27;2&#x27;),
                dynamicCallData(pfpContract),
                dynamicCallData(&#x27;0&#x27;),
              ],
            },
            {
              execution: execution(undefined, undefined, [6, 0, 0]),
              to: dynamicFelt(undefined, [6, 0]),
              selector: dynamicFelt(getSelectorFromName(&#x27;tokenURI&#x27;)),
              calldata: [dynamicCallData(undefined, [7, 1]), dynamicCallData(undefined, [7, 2])],
            },
          ],
        }),
      });

      if (Array.isArray(data)) {
        // Format data
        const size = parseInt(data[0], 16);
        const finalArray: string[][] = [];
        let index = 1;
        for (let i = 0; i &lt; size; i += 1) {
          if (index &lt; data.length) {
            const subArraySize = parseInt(data[index], 16);
            index += 1;

            const subArray = data.slice(index, index + subArraySize);
            finalArray.push(subArray);

            index += subArraySize;
          } else {
            break;
          }
        }

        const name = useDecoded(finalArray[0].slice(1).map((hexString) =&gt; BigInt(hexString)));

        const twitter =
          finalArray[2][0] !== &#x27;0x0&#x27; ? BigInt(finalArray[2][0]).toString() : undefined;
        const github = finalArray[3][0] !== &#x27;0x0&#x27; ? BigInt(finalArray[3][0]).toString() : undefined;
        const discord =
          finalArray[4][0] !== &#x27;0x0&#x27; ? BigInt(finalArray[4][0]).toString() : undefined;
        const proofOfPersonhood = finalArray[5][0] === &#x27;0x1&#x27;; // 10

        const profilePictureMetadata =
          data[0] === &#x27;0x9&#x27;
            ? finalArray[8]
                .slice(1)
                .map((val: string) =&gt; decodeShortString(val))
                .join(&#x27;&#x27;)
            : undefined;

        const profilePicture =
          profilePictureMetadata ||
          `https://starknet.id/api/identicons/${BigInt(finalArray[1][0]).toString()}`;

        return {
          name,
          twitter,
          github,
          discord,
          proofOfPersonhood,
          profilePicture,
        };
      }
      throw Error(&#x27;Error while calling aggregate function&#x27;);
    } catch (e) {
      if (e instanceof Error) {
        throw e;
      }
      throw Error(&#x27;Could not get user stark profile data from address&#x27;);
    }
  }
}
</textarea><pre id="annotations" style="display:none">[]</pre></div>
    <p class="footer-text">TypeScript Coverage Report generated by <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> and <a href="https://github.com/alexcanessa/typescript-coverage-report">typescript-coverage-report</a> at Thu, 25 Apr 2024 15:57:37 GMT</p>
    </body>
  </html>
  